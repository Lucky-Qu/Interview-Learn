# 练习题

## 一、Go语言基础与进阶

### 1.Go 的协程（goroutine）和线程有什么区别？
goroutine是由go发起的，线程是由CPU调度的，一个线程上可以容纳众多的goroutine  
【点评】✅正确。补充说明：goroutine是Go语言的轻量级线程，由Go运行时管理，调度开销小；线程是操作系统调度的基本单位，资源开销较大。

### 2.channel 是怎么实现协程之间通信的？无缓冲 channel 和 有缓冲 channel 有什么不同？
channel通过管道符来进行协程中的通信，无缓冲的channel在传输时接收方和发送方高度同步，有缓冲的channel消息收发可以异步进行  
【点评】✅正确。补充说明：channel本质上是一个类型安全的管道，用于在goroutine间传递数据。无缓冲channel发送操作会阻塞直到有接收方接收，保证同步；有缓冲channel有固定容量，发送操作只有在缓冲满时才阻塞，允许异步通信。

### 3.Go 的 defer 语句执行顺序是怎样的？
如果语句正常执行，defer语句在语句正常结束后执行，如果语句中途报错，会直接执行defer中的语句然后结束  
【点评】❌不完整。补充说明：defer语句无论函数是正常返回还是发生panic都会执行，且多个defer语句以后进先出（LIFO）顺序执行。

### 4.Go 中的 slice 和 array 有什么区别？slice 扩容的机制是怎样的？
slice的底层实现就是array，array是固定长度，slice是可变长度，会自动扩容，在数据量较小时，slice每次扩容是2倍的容量，在数据较多时，扩容是1.25倍的容量  
【点评】✅正确。补充说明：slice是对数组的一个动态视图，底层指向数组。扩容策略是当容量较小时，扩容倍数为2；容量较大时，扩容倍数约为1.25。

### 5.Go 是如何进行垃圾回收（GC）的？
采用三色标记法（更深的不知道了）  
【点评】❌不完整。补充说明：Go使用基于三色标记-清除的并发垃圾回收器，分为标记、扫描和清理三个阶段，支持并发和增量回收，减少STW（Stop The World）时间。

### 6.介绍一下 Go 的内存逃逸分析，什么情况下变量会逃逸到堆上？
不会  
【点评】❌错误。补充说明：Go的逃逸分析会判断变量的生命周期，如果变量在函数外被引用或返回，或者其地址被取并传递到函数外，则会逃逸到堆上，以保证变量的有效性。

### 7.你如何避免 goroutine 泄漏？
设置超时机制来避免goroutine泄漏  
【点评】✅正确。补充说明：除了设置超时，还可以通过context取消、关闭channel等方式避免goroutine无限等待导致泄漏。

### 8.你在 Go 项目中如何组织代码目录结构？（比如 api、internal、pkg 的区别）
通过代码的作用来区分代码目录结构  
【点评】❌不完整。补充说明：一般api目录存放接口定义，internal目录存放内部私有代码，pkg目录存放可被外部使用的公共库。合理划分有助于代码维护和权限控制。

### 9.你怎么看待 Go 的错误处理模式（error）？实际项目中你会怎么做更优雅的错误处理？
if err != nil，在实际项目中，对于可能会有错误的函数，go的官方规范是在最后一个返回值为err，在每次调用时都进行一次错误检查，从而保证代码的健壮性  
【点评】✅正确。补充说明：实际项目中还可以通过封装错误类型、使用errors包增强错误信息、结合日志和监控实现更优雅和可维护的错误处理。

## 二、组件设计 & 项目经验

### 1.你在项目中如何划分模块和组件？
根据功能来区分模块和组件，独立性很高的小功能抽离出来作为组件，大的由组件构成的抽离作为模块  
【点评】✅正确。补充说明：模块通常是较大的功能单元，组件是模块内更细粒度的功能单元，强调高内聚低耦合。

### 2.如果一个 toB 系统有用户管理、权限控制、日志审计模块，你会怎么设计？
因为是toB系统，所以更注重安全一点，对于权限和用户单独分表，一个用户可以有多种权限，来根据权限对日志审计有不同的操作  
【点评】✅正确。补充说明：设计时还应考虑权限模型（如RBAC、ABAC）、数据隔离、多租户支持和审计日志的不可篡改性。

### 3.如果接口需要支持高并发访问，你会怎么做？
首先前端方面可以采用nginx进行负载均衡，后端接收请求时并发请求数据，将高频数据进行缓存，再加上消息队列削峰填谷，从而实现高并发访问的功能  
【点评】✅正确。补充说明：还可以考虑数据库读写分离、限流降级、异步处理和服务拆分等手段。

## 三、数据库与中间件

### 1.事务的四大特性（ACID）分别是什么？
原子性，不知道了  
【点评】❌不完整。补充说明：ACID四大特性为原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

### 2.说一下 MySQL 的事务隔离级别，各级别分别可能出现什么问题？
不太清楚  
【点评】❌错误。补充说明：MySQL支持四种隔离级别：读未提交（可能出现脏读）、读已提交（避免脏读）、可重复读（避免不可重复读，MySQL默认）、串行化（避免幻读）。每级别对应不同的并发问题。

### 3.InnoDB 的索引为什么采用 B+ 树，而不是 B 树？
不太清楚  
【点评】❌错误。补充说明：B+树所有数据都存储在叶子节点，叶子节点通过链表相连，范围查询效率高；而B树数据分布在所有节点，不利于范围查询，且B+树结构更适合磁盘存储。

### 4.为什么要引入缓存？缓存和数据库如何保持一致性？
引入缓存可以加快查询的速度，对于常见数据的查询可以先去缓存，命中之后直接从缓存中取，降低了对数据库的访问  
缓存和数据库的一致性可以通过设置过期，或者当修改时先修改数据库，然后查询缓存里是否有，有的话进行修改  
【点评】✅正确。补充说明：常见缓存一致性策略包括写通过、写回、缓存失效等，复杂场景下需考虑分布式缓存一致性问题。

### 5.Redis 的常见数据结构有哪些？
键值对  
【点评】❌不完整。补充说明：Redis支持多种数据结构，如字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）、位图（Bitmap）、HyperLogLog等。

### 6.Redis 如何实现分布式锁？
不清楚  
【点评】❌错误。补充说明：Redis分布式锁常用setnx命令实现，结合过期时间和唯一标识保证锁的安全性。RedLock算法是更安全的分布式锁实现方案。

### 7.为什么要用消息队列？它能解决什么问题？
为了处理瞬时高并发请求，进行削峰填谷  
【点评】✅正确。补充说明：消息队列还支持异步处理、系统解耦、流量削峰、缓冲高峰压力和可靠消息传递。

### 8.如果消息队列里消息堆积了，你会如何排查？
先查看日志，然后从消费者开始一步步排查  
【点评】✅正确。补充说明：还应检查生产者是否正常发送，队列是否满载，网络是否异常，消费者处理能力是否跟不上等。

## 四、安全产品 & 系统设计

### 1.你觉得一个安全产品（比如 WAF、日志审计、漏洞扫描）在架构上需要考虑哪些点？
数据的加密保存  
【点评】✅正确。补充说明：还需考虑访问控制、审计追踪、数据完整性、防篡改、性能和高可用性等。

### 2.如果有一个 toB 客户要求：敏感日志不能被篡改，你会如何设计存储和访问机制？
我会考虑采用追加日志形式来写日志，从而避免日志被篡改，还可以加入时间戳的哈哈希值来加密  
【点评】✅正确。补充说明：可进一步采用不可变存储（如WORM存储）、链式哈希（区块链思想）保证日志不可篡改。

### 3.你在项目中如何防止 SQL 注入、XSS、CSRF 等常见攻击？
通过对前端传入的查询请求进行提取参数后处理再进行查询  
【点评】❌不完整。补充说明：防SQL注入应使用预编译语句；防XSS需对输入输出进行转义和过滤；防CSRF可采用Token验证、Referer检查等手段。

## 五、场景题

### 1.假设一个 Go 服务需要接入第三方支付系统，支付回调可能会并发调用多次，你如何保证订单只被处理一次？
当一个协程开始操作时调用锁来防止重复操作  
【点评】✅正确。补充说明：可使用分布式锁、幂等设计（如订单状态检查）、数据库唯一约束等保证幂等性。

### 2.你设计了一个接口，需要读取数据库和 Redis，如果 Redis 挂了，如何保证服务还能稳定提供数据？
降级直接访问数据库，或者采用Redis集群，当一个节点挂了转移到其他节点  
【点评】✅正确。补充说明：还可以设置缓存穿透保护，合理设计降级策略，保证服务可用性。

### 3.如果你写了一个高并发的接口，发现数据库压力过大，你会采用哪些优化手段？
增加实例，增加缓存，增加消息队列  
【点评】✅正确。补充说明：还可以做读写分离、分库分表、SQL优化、连接池调优等。

## 六、行为面试题

### 1.你之前有没有写过 toB 的需求？举例说一下。
没有  
【点评】无点评。

### 2.你在团队里遇到过代码风格不统一的情况吗？你是怎么处理的？
引入Code Review机制，使用文档来统一代码规范  
【点评】✅正确。补充说明：还可以引入自动化代码格式化工具和静态代码分析工具。

### 3.遇到不熟悉的中间件，你会怎么快速上手？
先通过技术文档来运行起来一个最小化实例，然后慢慢学习其进阶内容  
【点评】✅正确。补充说明：还可以结合社区资源、示例代码和实际项目需求快速掌握。